<!DOCTYPE html>
<html lang="jp">

<head>
    <meta charset="UTF-8">
    <title>DFSと枝刈り</title>
    <link rel="styleSheet" href="./../../../style.css" />
    <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
    <script type="text/javascript" src="./../../../main.js"></script>
    <script type="text/javascript"
        asyncsrc="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=MML_SVG"></script>
</head>
<!--
 &lt <
    <ol>
        <li></li>
    </ol>
 -->

<body>
    <div id="header"></div>
    <div id="breadcrumb"></div>
    <table class="noBorder">
        <tr>
            <td>作成日</td>
            <td>2025/05/09</td>
        </tr>
        <tr>
            <td>最終更新日</td>
            <td>2025/05/09</td>
        </tr>
    </table>

    <h1>
        DFSと枝刈り
    </h1>

    <div>
        <h2>
            背景
        </h2>

        <div>
            <p>
                競プロ典型90問をやっていたら、意外と枝刈りDFSで突破できる問題があったので、計算量の見積もりをしてみたいと思いました。
            </p>
            <p>折角なのでDFS自体についても整理します。本末転倒ですが、DFS・枝刈りについて整理しているだけで大分記事が膨らんだので、考察は別ページで行います。
            </p>
        </div>
    </div>

    <div>
        <h2>
            内容
        </h2>

        <ol>
            <li>DFSとは</li>
            <li>実装方法</li>
            <li>全探索とDFS</li>
            <li>枝刈り</li>
        </ol>
    </div>

    <div>
        <h2>
            DFSとは
        </h2>

        <div>
            <p>
                深さ優先探索の英訳「Depth First Search」の頭文字から来ています<a href="#ref">[2]</a>。より深い(遠い)場所に向かうことを優先するので深さ優先探索になります。
            </p>
            <p>
                次のグラフで具体例を考えます。
                丸が頂点、線が枝とします。
            </p>
        </div>

        <img src="graph.png" width="300">

        <div>
            <p>
                頂点1からDFSをした場合を考えます。
            </p>
            <p>
                頂点1から移動できるのは頂点2と頂点3です。とりあえず頂点2に移動します。このとき、さらに頂点1から遠ざかるように移動できる枝は存在しません。探索を諦めて、頂点1に戻ります。
            </p>
            <p>
                再度頂点1から探索を行います。頂点2には移動したので、次は頂点3に移動します。
            </p>
            <p>
                頂点3からは頂点4・5に移動できます。
            </p>
            <p>
                とりあえず頂点4に移動します。この時、頂点1から遠ざかる方に移動できないので、探索を諦めて頂点3に返ります。
            </p>
            <p>
                戻って来た頂点3から移動できる点は頂点4・5ですが、4はもう探索済みなので残った頂点5に行きます。
            </p>
            <p>
                このとき、頂点1から遠ざかる移動はもうできないので、頂点3に戻ります。頂点3でも頂点1から遠ざかるように移動はできません。したがって、頂点3からも帰り頂点1に移動します。
            </p>
            <p>
                頂点1から移動できる頂点2・3は訪問済みなので、DFSが終了します。
            </p>
            <p>
                たどった順番は次の図のようになります。
            </p>
        </div>

        <img src="DFS1_order.png" width="300">

        <div>
            <p>
                便宜上戻った場合の頂点にも数字を振っています。実際にプログラムで利用する際は、行きか帰りのどちらかでしか処理をしないはずです。
            </p>
        </div>

        <div>
            <p>
                頂点5から探索した場合を考えます。
            </p>
            <p>
                頂点3にしか行けないのでとりあえずそちらへ移動。
            </p>
            <p>
                そこから頂点1に移動してみます。さらに奥に進めるので移動します。頂点2に着きます。行き止まりなので、帰ります。頂点1から移動してないところはないので、頂点3まで帰ります。
            </p>
            <p>
                まだ見てない枝を確認すると、頂点4に移動する枝があります。この枝に進みます。
            </p>
            <p>
                頂点4に来ましたが、行き止まりなので帰ります。
            </p>
            <p>
                頂点3から分岐する道は全て見たので帰ります。
            </p>
            <p>
                頂点5に帰ってきて、頂点5も見てない枝がないので終了です。
            </p>
            <p>
                辿った順番は以下の図の通りです。
            </p>
        </div>

        <img src="DFS5_order.png" width="300">

        <div>
            <p>
                突然ですが、迷路の攻略法として、左手法 <a
                    href="#ref">[1]</a>というものがあります。迷路で左手を壁に当てながら進むと出口にたどり着ける、というものです。外周からつながっていないとこに出口があると意味をなさなくなるので意外と実用的はありませんが。
            </p>
            <p>
                ループがないグラフを迷路と見立て、壁に左手を当てたまま進んだとき、その経路はDFSに該当します。
            </p>
            <p>
                意外と難しいことをやっていない、というのが伝われば幸いです。
            </p>
        </div>
        <div>
            <p>
                一度通った頂点に進まないことで、ループがあってもDFSは達成できます。一般的なグラフに対して実装するときは、一度通った頂点に入らないように実装するはずなので、普通に作ったらループでもDFSできるようになるはずです。
            </p>
            <p>
                ループがあるグラフに対して、探索が効率的になることはあまりないと思いますが。
            </p>
        </div>
    </div>

    <div>
        <h2>
            実装方法
        </h2>

        <div>
            <p>
                実装方法という項目を作っておいてなんですが、別の方の記事に丸投げします(<a href="https://algo-logic.info/dfs/">こちら</a>
                <a href="#ref">[2]</a>)。実装例を後で出すのでお許しを。
            </p>
            <p>
                再起関数で実装する方法と、スタックを利用して実装する方法があるようです。
            </p>
            <p>
                再起関数で実装すると割とすぐに(それでも手元の環境だと40000回程度のネストは大丈夫)スタックオーバーフローしてしまうのでどうしたものかと思ってましたが、これで解決できます。
            </p>
            <p>
                再起関数でしか実装したことがなかったので勉強になりました。
            </p>
        </div>
    </div>

    <div>
        <h2>
            全探索とDFS
        </h2>

        <div>
            <p>
                次の問題を考えて見ましょう。
            </p>
        </div>

        <div class="box1">
            <p>
                1 ~ 3 の数字のみからなる3桁の整数のうち、Mの倍数となる数字の個数を答えよ。
            </p>
        </div>

        <div>
            <p>
                これは桁数が固定されているので3重のfor文の全探索が簡単に行えます。
            </p>
            <p>
                では、次の問題はどうでしょうか?
            </p>
        </div>

        <div class="box1">
            <p>
                1 ~ 3の数字のみからなるN桁の整数のうち、Mの倍数となる数字の個数を答えよ。
            </p>
        </div>

        <div>
            <p>
                桁数が可変になってしまったので、多重のfor文で全探索は書けなくなってしまいました。
            </p>
            <p>
                ここで、以下のグラフを利用することを考えてみます。3~N-1個目の要素は省略しました。
            </p>
        </div>

        <img src="tree.PNG" width="300">

        <div>
            <p>
                グラフの作成方法は次の通りです。
            </p>
            <p>
                根となる頂点を作成し、その頂点から1~3の数字に対応する頂点を生やします。新しく作成した頂点にも1~3の数字対応する頂点を新しく生やします。
            </p>
            <p>
                この操作をN回行います。
            </p>
        </div>

        <div>
            <p>
                このグラフで最も深い点(N個目の頂点)に辿り着いたときに、通った経路にある数字を各桁に対応させることでN桁の数字を1つ決定することができます。
            </p>
        </div>

        <div>
            <p>
                難しく書いてますが、要は樹形図を作って全探索しているわけです。
            </p>
        </div>

        <div>
            <p>
                ではこのグラフに対してDFSを利用します。
            </p>
            <p>
                今いる深さと今いる頂点に書かれた数字を使うことでN桁の数字を作成できます。深さkに入ったとき、数字が3だったら、k桁目を3とするわけです。
            </p>
            <p>
                各頂点の数字を利用したいので、再起関数の方が都合がよいです。
            </p>
        </div>

        <div>
            <p>
                以下実装例です。
            </p>
        </div>

        <pre><code>#include &lt;bits/stdc++.h>
using namespace std;

int N, M;
long long ans = 0;

void dfs(vector&lt;int>digitNum)
{
    // 最後の桁まで辿り着いた場合
    if (digitNum.size() == N)
    {
        long long num = 0;
        long long pow = 1;
        // ベクトルの数字をそのまま10進数の数字に変換
        for (int i = N - 1; i >= 0; i--)
        {
            num += digitNum[i] * pow;
            // 10倍して1つ左の数字に対応させる
            pow *= 10;
        }

        // Mの倍数ならインクリメント
        if (num % M == 0)
        {
            ans++;
        }

        // デバッグ用に数字を表示してみる
        // cout &lt;&lt; num &lt;&lt; endl;
        
        // もう行先はないので終了
        return;
    }

    // dfsの再起呼び出し
    for (int i = 1; i &lt;= 3; i++)
    {
        // ベクトルの末尾に数字を追加
        vector<int> addedList = digitNum;
        addedList.push_back(i);
        dfs(addedList);
    }
}

int main()
{
    // 入力
    cin >> N >> M;

    // 全探索
    // 空のベクトルでスタート
    dfs(vector&lt;int>(0));

    // 答えの表示
    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}

</code></pre>

        <div>
            <p>
                vectorを引数にする形で実装したことがなかったので練習がてら書いてみました。
            </p>
            <p>
                欲をいうならaddedListを作らずに行きたいのですが、cppでの実装方法は見当が付かず。kotlinとか関数型使えるなら簡単そうだけど。
            </p>
            <p>
                stackで実装する方法も考えたんですけどこちらも見当が付かず。
            </p>
        </div>

        <div>
            <p>
                今回は仮想的にグラフを作りDFSする体で解説しましたが、再起関数を用いて全通りの調べ上げを行うこと自体もDFSと呼べるようです
                <a href="#ref">[3]</a>(<a
                    href="https://qiita.com/e869120/items/25cb52ba47be0fd418d6#%E5%85%A8%E6%8E%A2%E7%B4%A2%E3%81%AE%E5%85%B7%E4%BD%93%E7%9A%84%E3%81%AA%E5%AE%9F%E8%A3%85">このへん</a>)。
            </p>
            <p>
                これを踏まえるとスタックでの実装方法がわからないのもまぁ納得です。
            </p>
        </div>

        <div>
            <p>
                n = 2で実行したときのデバッグ用出力はこちらです
            </p>
        </div>

        <pre><code>11
12
13
21
22
23
31
32
33</code></pre>

        <div>
            <p>
                樹形図を上から見た数字が出力されてます。
            </p>
            <p>
                このように、DFSはものを選ぶ操作にも利用することができます。
            </p>
            <p>
                true・falseにすることで入れる/入れない・選択する/選択しないの問題も解けますね。
            </p>
        </div>
    </div>

    <div>
        <h2>枝刈り</h2>
        <div>
            <p>
                先ほどの問題をさらに改変します。
            </p>
        </div>

        <div class="box1">
            <p>
                1 ~ 3の数字のみからなる整数のうち、各桁の数字の和がNで、Mの倍数となる数字の個数を答えよ。
            </p>
        </div>

        <div>
            <p>
                桁数の制約がなくなり、各桁の和がNという制約になりました。
            </p>
            <p>
                全て1の場合はN桁、全て3の場合はおおよそN/3桁となります(Nが3の倍数じゃないと全て3にはなりません)。桁数が選んでいる数字によって幅がでてしまい困ります。
            </p>
        </div>
        <div>
            <p class=>
                とりあえず、先ほどと同じ樹形図を考えます。
            </p>
        </div>

        <img src="tree.PNG" width="300">

        <div>
            <p>
                N = 4 として問題を考えます。
            </p>
            <p>
                このとき、一番上の経路(全て1の経路)は深さN(4)まで潜って初めて各桁の和が4になります。
            </p>
            <p>
                一方、一番下の経路(全て3の経路)は2つ目の3を選んだ時点で各桁の和が6となり、4を超えてしまいます。……ということは、この経路はこれ以上深くまで探索する必要がないということになります。
            </p>
            <p>
                単純なDFSでは行けるところまで行ってから引き返しますが、枝切りではこれ以上探索しなくていいと判断できた時点で、その経路の探索を諦めます。
            </p>
            <p>
                グラフを切り落とすイメージです。
            </p>
        </div>

        <img src="tree_cut.png" width="300">

        <div>
            <p>
                制約を満たさないことが判明した時点や、解の質が悪いことが判明した時点で探索を切り上げることで、問題を全探索より高速に解くことができるようになります。
            </p>

            <p>
                実装例は以下の通りです。
            </p>
        </div>

        <code><pre>#include &lt;bits/stdc++.h>
using namespace std;

int N, M;
long long ans = 0;

void dfs(
    int r,       // 作った数字をMで割ったあまり
    int digitSum // 各桁の和
)
{
    // 各桁の合計がNより大きい場合
    if (N &lt; digitSum)
    {
        // 枝刈り処理
        // これ以上数字を追加してもNより大きい数字にしかならないので終了
        return;
    }

    // デバッグ用に数字を表示してみる
    // cout &lt;&lt; r &lt;&lt; endl;

    // 各桁の合計がNの場合
    if (digitSum == N)
    {
        // 余りが0ならMの倍数
        if (r == 0)
        {
            ans++;
        }

        return;
    }

    // dfsの再起呼び出し
    for (int i = 1; i &lt;= 3; i++)
    {
        // 10倍で左シフト　末尾にiを追加
        int newNum = r * 10 + i;
        // Mで割った余りを導出
        int newR = newNum % M;

        dfs(
            newR,        // 新しいあまりの数
            digitSum + i // 新しい各桁の和
        );
    }
}

int main()
{
    // 入力
    cin >> N >> M;

    // 全探索
    // 各桁の和も数字も0からスタート
    dfs(0, 0);

    // 答えの表示
    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}</pre></code>

        <div>
            <p>
                先ほどはvectorを使っていたのに対し、今回は数字を直接計算して数字を次の関数に渡す処理に変えました。また、前もって割る実装も入れてます。
            </p>
            <p>
                普通に数値を出していたのではオーバーフローしてしまうからです。また、途中まで選択した数字は共通で利用できるので、利用した方がお得です(12の末尾に数字をつけるなら12に前処理をできる)。
            </p>
            <p>
                newRの%Mの処理をコメントアウトして、デバッグ用に出力した値は以下の通りです。N=4の場合です。
            </p>
        </div>

        <pre><code>0
1
11
111
1111
112
12
121
13
2
21
211
22
3
31
</code></pre>

        <div>
            <p>
                各桁の合計が4以下の数字だけ表示されます。余計な探索を行っていないことがわかります
            </p>
        </div>

        <div>
            <details>

                <summary>
                    数字を全て決定する前に余りの計算をしていい理由
                </summary>
                
                <div>
                    <p>
                        前半のコードはわかりやすさのために、全ての数字を並べた数字を作っていましたが、後半のコードは都度Mの余りをとっています。何の説明もなく受け入れられない人もいるかと思うので、軽く説明しておきます。
                    </P>
                    <p>
                        ある数字aの末尾に1桁の数字iを付け加えた数は、10a + iになります。aの末尾に0を入れて、iを足してます。iが2桁なら10倍じゃなくて100倍が必要です。
                    </p>
                    <p>
                        要は、足し算と掛け算で末尾に数字を追加する操作は実現されるということです。
                    </p>
                </div>
                <div>
                    <p>
                        また、合同式には次のような特性があります。
                    </p>
                    <ol>
                        <li>
                            合同式は和を取れる
                        </li>
                        <li>
                            合同式は積を取れる
                        </li>
                    </ol>
                    <p>
                        合同式に詳しくない方は<a href="https://manabitimes.jp/math/683">こちら</a><a
                            href="#ref">[4]</a>も参考にするといいかも入れません。
                    </p>
                </div>
                <div>
                    <p>
                        上記の特性を組み合わせると、
                    </p>
                    <p>
                        ・シフトしてから末尾に数字を入れて余りを求める
                    </p>
                    <p>
                        ・余りを取ってからシフトして、末尾に数字を末尾に入れて余りを求める
                    </p>
                    <p>
                        2つの操作は結果が一致することがわかります。
                    </p>
                </div>
                <div>
                    <p>
                        <math>
                            <msub>
                                <mi>a</mi>
                                <mi>n</mi>
                            </msub>
                            <msub>
                                <mi>a</mi>
                                <mi>n-1</mi>
                            </msub>
                            <mi>……</mi>
                            <msub>
                                <mi>a</mi>
                                <mi>2</mi>
                            </msub>
                            <msub>
                                <mi>a</mi>
                                <mi>1</mi>
                            </msub>
                        </math>
                        と並んだ10進数は、
                    </p>
                    <p>
                        <math>
                            <msub>
                                <mi>a</mi>
                                <mi>1</mi>
                            </msub>
                            <mo>&plus;</mo>
                            <mn>10</mn>
                            <mo>(</mo>
                            <msub>
                                <mi>a</mi>
                                <mi>2</mi>
                            </msub>
                            <mo>+</mo>
                            <mn>10</mn>
                            <mo>(</mo>
                            <mi>……</mi>
                            <mo>&plus;</mo>
                            <mn>10</mn>
                            <mo>(</mo>
                            <msub>
                                <mi>a</mi>
                                <mi>n-1</mi>
                            </msub>
                            <mo>&plus;</mo>
                            <mn>10</mn>
                            <msub>
                                <mi>a</mi>
                                <mi>n</mi>
                            </msub>
                            <mo>)</mo>
                            <mi>……</mi>
                            <mo>)</mo>
                            <mo>)</mo>
                        </math>
                    </p>
                    <p>
                        と表現できます。これは10a + iの話をanから順に適応していくと導けます。
                    </p>
                    <p>
                        先ほどの話を括弧の内側から順に適応していくと余りのみに注目していても、最終的な数字の余りは出せることが伝われば幸いです
                    </p>
                </div>
            </details>
        </div>
    </div>

    <div>
        <h2>
            まとめ
        </h2>

        <div>
            <p>
                以上、DFSと枝刈りについて整理しました。
            </p>
        </div>
        <div>
            <p>
                dfsがstackでbfsがqueueなのは、データ構造と探索方法の対比が出ていて面白いなと思いました。
            </p>
            <p>
                今後の課題は、典型問題で触れた枝刈りDFSの計算量の見積もりを引き続き計算することと、stackでのDFSの実装もしてみることですかね。
            </p>
        </div>
        <div>
            <p>
                とまぁ今回はこの辺で。ではまた。
            </p>
        </div>
    </div>

    <!-- <a href="#ref">[]</a> -->

    <h2 id="ref">
        参考
    </h2>

    <ol>
        <li>『左手法』 ニコニコ大百科(仮) (2025/04/29)
            <br><a href="https://dic.nicovideo.jp/a/%E5%B7%A6%E6%89%8B%E6%B3%95">
                https://dic.nicovideo.jp/a/%E5%B7%A6%E6%89%8B%E6%B3%95
            </a>
        </li>
        <li>『深さ優先探索(Depth First Search)の基本』 アルゴリズムロジック (2025/04/29)
            <br><a href="https://algo-logic.info/dfs/">
                https://algo-logic.info/dfs/
            </a>
        </li>
        <li>『たのしい探索アルゴリズムの世界【前編：全探索、bit全探索から半分全列挙まで】』 Qiita (2025/04/30)
            <br><a href="https://qiita.com/e869120/items/25cb52ba47be0fd418d6">
                https://qiita.com/e869120/items/25cb52ba47be0fd418d6
            </a>
        </li>
        <li>『合同式(mod)の意味とよく使う６つの性質』
            高校数学の美しい物語 (2024/04/30)
            <br><a href="https://manabitimes.jp/math/683">
                https://manabitimes.jp/math/683
            </a>
        </li>
        <!-- <li>『』 ページ名 ()
            <br><a href="">

            </a>
        </li> -->
    </ol>

    <div id="relatedList"></div>

    <script>
        $(document).ready(function () {
            var dir = "../../../"
            articleHeaderFooter(
                dir,
                "kyopro",
            );
        });
    </script>
</body>

</html>